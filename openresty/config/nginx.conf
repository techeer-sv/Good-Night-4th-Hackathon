worker_processes auto;

# ----- (옵션) 환경변수로 Redis/백엔드 설정 오버라이드 -----
env REDIS_HOST;
env REDIS_PORT;
env REDIS_PASSWORD;
env REDIS_DB;
env REDIS_USER;
env FCFS_USER_TTL;
env FCFS_REDIS_PREFIX;
env BACKEND_HOST;
env BACKEND_PORT;

events {
  worker_connections 4096;
}

http {
  # ----- 기본 튜닝/로그 -----
  sendfile on;
  tcp_nopush on;
  tcp_nodelay on;
  keepalive_timeout 65s;
  server_tokens off;

  # Docker / Podman DNS
  # resolver 10.89.0.1 valid=30s ipv6=off;   # Podman 예시
  resolver 127.0.0.11 valid=30s ipv6=off;

  log_format fcfs '$msec "$request" $status $request_time $upstream_response_time '
                  '$request_id $remote_addr $http_x_forwarded_for';
  access_log /var/log/nginx/access.log fcfs;
  error_log  /var/log/nginx/error.log info;

  real_ip_header X-Forwarded-For;
  set_real_ip_from 0.0.0.0/0;

  lua_package_path '/usr/local/openresty/lualib/?.lua;/etc/openresty/lua/?.lua;;';
  lua_shared_dict lua_cache 1m;

  # ----- 업스트림(백엔드 API) -----
  upstream backend_upstream {
    server   backend:5800 max_fails=3 fail_timeout=10s;
    keepalive 32;
  }

  # ----- 레이트리밋: /fcfs/join -----
  limit_req_zone $binary_remote_addr zone=fcfs:10m rate=5r/s;

  # ----- CORS 허용(origin allowlist) -----
  map $http_origin $cors_origin {
    default "";
    "~^https?://localhost(:\d+)?$"    $http_origin;
    "~^https?://127\.0\.0\.1(:\d+)?$" $http_origin;
    # 배포 시: "~^https?://app\.example\.com$" $http_origin;
  }

  # (헤더 노출: X-Fcfs-Seq 필요)
  map $cors_origin $cors_expose {
    default "";
    ""      "";
    ~.      "X-Fcfs-Seq";
  }

  map $http_x_fcfs_seq $fcfs_seq_pass { default $http_x_fcfs_seq; }

  # 편의용 변수
  map $http_x_admin_token $admin_token_pass { default $http_x_admin_token; }
  map $http_x_user_id     $user_id_pass     { default $http_x_user_id; }

  server {
    listen 80;

    # =========================
    # Health endpoints
    # =========================
    location = /health {
      default_type text/plain;
      return 200 "ok\n";
    }

    location = /healthz {
      default_type text/plain;
      return 200 "ok\n";
    }

    # =========================
    # FCFS: /fcfs/join (게이트웨이에서 직접 응답)
    # =========================
    location = /fcfs/join {
      limit_req zone=fcfs burst=30 nodelay;

      # ---- CORS ----
      if ($cors_origin != "") {
        add_header Access-Control-Allow-Origin  $cors_origin always;
        add_header Vary                         Origin always;
        add_header Access-Control-Allow-Methods "GET, POST, OPTIONS" always;
        add_header Access-Control-Allow-Headers "DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,X-User-Id" always;
        add_header Access-Control-Expose-Headers "$cors_expose" always;   # ★ X-Fcfs-Seq 노출
        add_header Access-Control-Max-Age       1728000 always;
      }
      if ($request_method = OPTIONS) {
        add_header Content-Type  "text/plain; charset=utf-8" always;
        add_header Content-Length 0 always;
        return 204;
      }

      # ---- 게이트웨이에서 시퀀스 발급 & 응답(JSON + 헤더) ----
      content_by_lua_block {
        local cjson = require "cjson.safe"

        local function respond(code, tbl, extra)
          ngx.status = code
          ngx.header["Content-Type"] = "application/json"
          if extra then
            for k, v in pairs(extra) do
              ngx.header[k] = v
            end
          end
          ngx.say(cjson.encode(tbl or {}))
          return
        end

        local hdrs = ngx.req.get_headers()
        local user = hdrs["X-User-Id"] or hdrs["x-user-id"]
        if not user or user == "" then
          return respond(400, { success = false, reason = "missing_user_header" })
        end

        -- Redis connect + AUTH + DB select
        local redis = require "resty.redis"
        local r = redis:new()
        r:set_timeout(100)

        local rh = os.getenv("REDIS_HOST") or "redis"
        local rp = tonumber(os.getenv("REDIS_PORT") or "6379")
        local ok, err = r:connect(rh, rp)
        if not ok then
          return respond(500, { success = false, reason = "redis_connect_failed", error = err })
        end

        local ru = os.getenv("REDIS_USER")
        local rpw = os.getenv("REDIS_PASSWORD")
        if rpw and rpw ~= "" then
          local aok, aerr
          if ru and ru ~= "" then
            aok, aerr = r:auth(ru, rpw)   -- Redis 6+ ACL
          else
            aok, aerr = r:auth(rpw)       -- requirepass
          end
          if not aok then
            return respond(500, { success = false, reason = "redis_auth_failed", error = aerr })
          end
        end

        local db = tonumber(os.getenv("REDIS_DB") or "0")
        if db and db > 0 then
          local sok, serr = r:select(db)
          if not sok then
            return respond(500, { success = false, reason = "redis_select_failed", error = serr })
          end
        end

        local prefix = os.getenv("FCFS_REDIS_PREFIX") or "fcfs"
        local ttl = tonumber(os.getenv("FCFS_USER_TTL") or "600")

        local user_key = prefix .. ":user:" .. user
        local seq_key  = prefix .. ":seq"

        local setnx_ok, setnx_err = r:setnx(user_key, 1)
        if setnx_ok == false then
          return respond(500, { success = false, reason = "redis_setnx_failed", error = setnx_err })
        end
        if setnx_ok == 0 then
          return respond(409, { success = false, reason = "already_reserved" })
        end
        r:expire(user_key, ttl)

        local seq, incr_err = r:incr(seq_key)
        if not seq then
          return respond(500, { success = false, reason = "redis_incr_failed", error = incr_err })
        end

        ngx.header["X-Fcfs-Seq"] = tostring(seq)
        -- 커넥션 재사용(선택)
        r:set_keepalive(10000, 100)

        return respond(200, { success = true, sequence = seq, userTtlRemaining = ttl })
      }
    }

    # =========================
    # 좌석 목록(정확 일치) - 슬래시 보정 후 프록시
    # =========================
    location = /api/v1/seats {
      if ($cors_origin != "") {
        add_header Access-Control-Allow-Origin  $cors_origin always;
        add_header Vary                         Origin always;
        add_header Access-Control-Allow-Methods "GET, POST, OPTIONS" always;
        add_header Access-Control-Allow-Headers "DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,X-User-Id,X-Admin-Token,X-Fcfs-Seq" always;
        add_header Access-Control-Max-Age       1728000 always;
      }
      if ($request_method = OPTIONS) {
        add_header Content-Type  "text/plain; charset=utf-8" always;
        add_header Content-Length 0 always;
        return 204;
      }

      # /api/v1/seats → /api/v1/seats/ 로 내부 리라이트(백엔드가 디렉터리형 라우팅일 때)
      rewrite ^/api/v1/seats$ /api/v1/seats/ break;

      proxy_set_header Host               $host;
      proxy_set_header X-Request-Id       $request_id;
      proxy_set_header X-Real-IP          $realip_remote_addr;
      proxy_set_header X-Admin-Token      $admin_token_pass;
      proxy_set_header X-User-Id          $user_id_pass;
      proxy_set_header X-Fcfs-Seq         $fcfs_seq_pass;
      # location /api/ { ... } 와 /api/v1/seats 블록 둘 다에 추가
      proxy_set_header Accept "application/json";
      proxy_set_header X-Gateway-Version  1;
      proxy_http_version 1.1;
      proxy_set_header Connection "";

      proxy_read_timeout 30s;
      proxy_send_timeout 30s;

      proxy_pass http://backend_upstream;
    }

    # =========================
    # 일반 API 패스스루 (/api/ 이하 전부)
    #   - /api/v1/seats/reservation/fcfs 포함
    # =========================
    location /api/ {
      if ($cors_origin != "") {
        add_header Access-Control-Allow-Origin  $cors_origin always;
        add_header Vary                         Origin always;
        add_header Access-Control-Allow-Methods "GET, POST, PUT, PATCH, DELETE, OPTIONS" always;
        add_header Access-Control-Allow-Headers "DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,X-User-Id,X-Admin-Token,X-Fcfs-Seq" always;
        add_header Access-Control-Max-Age       1728000 always;
      }
      if ($request_method = OPTIONS) {
        add_header Content-Type  "text/plain; charset=utf-8" always;
        add_header Content-Length 0 always;
        return 204;
      }

      proxy_set_header Host               $host;
      proxy_set_header X-Request-Id       $request_id;
      proxy_set_header X-Real-IP          $realip_remote_addr;
      proxy_set_header X-Admin-Token      $admin_token_pass;
      proxy_set_header X-User-Id          $user_id_pass;
      proxy_set_header X-Fcfs-Seq         $fcfs_seq_pass;
      proxy_set_header X-Gateway-Version  1;
      # location /api/ { ... } 와 /api/v1/seats 블록 둘 다에 추가
      proxy_set_header Accept "application/json";
      proxy_http_version 1.1;
      proxy_set_header Connection "";

      proxy_read_timeout 30s;
      proxy_send_timeout 30s;

      proxy_pass http://backend_upstream;
    }

    # =========================
    # Redis 디버그(옵션)
    # =========================
    location = /redis-test {
      default_type application/json;
      content_by_lua_block {
        local cjson = require "cjson.safe"
        local redis = require "resty.redis"
        local r = redis:new()
        r:set_timeout(100)

        local function respond_err(step, err)
          ngx.status = 500
          ngx.say(cjson.encode({ ok = false, step = step, error = err }))
          return
        end

        local rh = os.getenv("REDIS_HOST") or "redis"
        local rp = tonumber(os.getenv("REDIS_PORT") or "6379")
        local ok, err = r:connect(rh, rp)
        if not ok then
          return respond_err("connect", err)
        end

        local ru = os.getenv("REDIS_USER")
        local rpw = os.getenv("REDIS_PASSWORD")
        if rpw and rpw ~= "" then
          local aok, aerr
          if ru and ru ~= "" then
            aok, aerr = r:auth(ru, rpw)
          else
            aok, aerr = r:auth(rpw)
          end
          if not aok then
            return respond_err("auth", aerr)
          end
        end

        local db = tonumber(os.getenv("REDIS_DB") or "0")
        if db and db > 0 then
          local sok, serr = r:select(db)
          if not sok then
            return respond_err("select", serr)
          end
        end

        local pong, perr = r:ping()
        if not pong then
          return respond_err("ping", perr)
        end

        ngx.say(cjson.encode({ ok = true, ping = pong }))
      }
    }
  }
}