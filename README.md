# Good-Night-4th-Hackathon
공연 좌석 예매 시스템 풀스택 구현

## 안내사항

- 본 레포지토리를 **fork**하여 과제를 수행하고, 완료시 PR을 보냅니다.
- 과제의 소스코드는 본인의 GitHub 레포지토리에 **Public**으로 올려주세요.
- 진행 간 문의사항은 이 레포지토리의 Issue로 등록해주세요.
- 구현 내용은 README.md 하단에 이어서 작성해 주세요.

## 과제 목표

공연 좌석 예매 시스템 구현

### 기술 스택

- Backend: 자유 선택 (Spring Boot, Node.js, Django, FastAPI 등)
- Frontend: 자유 선택 (React, Vue, Svelte, Vanilla JS 등)
- Database: 자유 선택
- 선택한 기술 스택에 대한 이유를 README에 간단히 설명해주세요

### 평가 항목

- 문제 해결 접근 방식에서 기술적 의사결정
- 구현 완성도와 문서화 수준

## 요구사항

### 최소 요구사항
> 아래 목표들을 달성하기 위한 구현 방법은 자유롭게 선택하세요.

1. **좌석 현황 표시**
    - 3x3 격자 형태로 총 9개의 좌석 표시
    - 각 좌석의 예약 가능/불가능 상태를 시각적으로 구분
2. **좌석 예약 기능**
    - 사용자가 빈 좌석을 클릭하여 선택
    - 페이지를 이동하여 예약자 정보 입력
    - 정보 입력 완료 후 예약 확정 시도
        - 99% 확률로 예약 성공 처리
        - 1% 확률로 의도적 실패 처리
    - 예약 성공/실패에 대한 명확한 피드백 제공
3. **API 엔드포인트**
    - 좌석 목록 조회 API
    - 좌석 예약 요청 API
    - HTTP 통신을 통한 데이터 교환
4. **코드 품질 보장**
    - 테스트 코드
    - 타입 체크
    - 린팅

### 기본 요구사항

> 아래 목표들을 달성하기 위한 구현 방법은 자유롭게 선택하세요.

> 각 목표를 어떻게 해결했는지 README에 설명해주세요.

1. **사용자 경험 개선**
    - **목표**: 사용자가 서비스를 이용할 때 발생할 수 있는 불편함 최소화
    - **예시**
        - 직관적인 UI
        - 네트워크 지연이 발생했을 때 편의성
        - 예약이 실패했을 때 편의성
        - 모바일에서 접속했을 때 편의성
2. **안정적인 서비스 운영**
    - **목표**: 예상치 못한 상황에서도 서비스가 안정적으로 동작
    - **예시**
        - 잘못된 요청이 들어왔을 때
        - 존재하지 않는 좌석을 예약하려 할 때
        - 서버 에러가 발생했을 때
        - 데이터 정합성 보장

### 심화 요구사항

> 아래 목표들을 달성하기 윈한 구현 방법은 자유롭게 선택하세요.

> 각 목표를 달성했음을 검증할 방법을 마련하세요.

> 시도한 방법이 어떤 방식으로 문제를 해결했으며 보유한 한계점에 대해 상세히 README에 설명해주세요.


1. **동시성 제어**
    - **상황**: 여러 사용자가 동시에 같은 좌석을 예약하려고 시도하는 경우
    - **목표**: 한 좌석에 대해 단 한 명만 예약에 성공하도록 보장
2. **실시간 좌석 상태 동기화**
    - 상황: UI에서 사용자들이 이미 선택된 좌석을 선택하게 되는 경우
    - 목표: 실시간 좌석 예약 상태를 확인할 수 있도록 실시간 동기화 제공
3. **선택한 좌석에 대한 우선순위 제공**
    - 상황 : 좌석 선택 후 예약자 정보를 입력하는 동안 다른 사용자가 좌석을 예약하게 되는 경우
    - 목표: 동일 좌석에 대해 먼저 선택을 한 사용자에게 예약 우선순위 제공

## 참고사항

### 진행 방식

- 최소 요구사항을 먼저 완성한 후 기본 기능을 구현해주세요
- 심화 요구사항은 구현에 실패해도 고민한 해결 방법이 있으면 작성해주세요.

### 필수 제출 항목

- **README.md**: 다음 내용을 반드시 포함
    - 프로젝트 실행 방법 (상세하게)
    - 기술 스택 선택 이유
    - 구현한 요구사항 체크리스트
    - 각 요구사항별 해결 방법 설명

### 선택 제출 항목

- 아키텍처 다이어그램
- 시연 영상 또는 GIF

---

<!-- 구현 내용 작성 -->

## 프로젝트 실행 방법

본 프로젝트는 Docker Compose를 사용하여 간편하게 실행할 수 있습니다.

1.  **Docker 설치**: 시스템에 [Docker](https://www.docker.com/get-started)가 설치되어 있어야 합니다.
2.  **레포지토리 클론**:
    ```bash
    git clone <your-fork-url>
    cd Good-Night-4th-Hackathon
    ```
3.  **Docker Compose 실행**:
    ```bash
    docker-compose up --build
    ```
4.  **애플리케이션 접속**:
    -   웹 브라우저를 열고 `http://localhost` 로 접속합니다. (프론트엔드 Nginx 서버는 80번 포트를 사용합니다.)
    -   백엔드 API는 `http://localhost:8080` 에서 직접 접근할 수 있습니다.

## 테스트 실행 방법

### 백엔드 테스트
```bash
cd backend
./gradlew test
```

### 프론트엔드 테스트
```bash
cd frontend
npm run lint        # ESLint 검사
npm run build       # TypeScript 타입 체크
```

### 통합 테스트만 실행
```bash
cd backend
./gradlew test --tests "com.example.demo.integration.SeatIntegrationTest"
```

## 기술 스택 선택 이유

-   **Backend (Spring Boot + Gradle + JPA)**
    -   **Spring Boot**: 강력한 의존성 주입(DI), 방대한 레퍼런스, 안정적인 생태계를 기반으로 빠르고 견고한 서버를 구축할 수 있습니다. 
    -   **Gradle**: Maven 대비 빠른 빌드 속도와 유연한 스크립트 작성이 가능하여 개발 생산성이 높습니다.
    -   **Spring Data JPA**: SQL을 직접 작성하지 않고도 객체 지향적으로 데이터베이스를 조작할 수 있어 생산성이 높고, 유지보수가 용이합니다.
    -   **JPA Optimistic Locking**: `@Version` 어노테이션을 통해 동시성 제어를 구현했습니다.

-   **Frontend (React + Vite)**
    -   **React**: 컴포넌트 기반 아키텍처를 통해 재사용 가능하고 논리적인 UI 구조를 만들 수 있습니다. 방대한 커뮤니티와 자료 덕분에 문제 해결이 용이합니다.
    -   **Vite**: 매우 빠른 빌드 속도와 Hot Module Replacement(HMR)를 제공하여 개발 경험을 크게 향상시킵니다.
    -   **TypeScript**: 정적 타이핑을 통해 런타임 에러를 사전에 방지하고, 코드의 안정성과 가독성을 높입니다.

-   **Database (SQLite)**
    -   별도의 서버 설정 없이 파일 기반으로 동작하여 가볍고 빠르게 로컬 환경을 구축할 수 있습니다. 소규모 프로젝트나 프로토타이핑에 적합하여 본 과제에 채택했습니다.

-   **Containerization (Docker)**
    -   Docker를 통해 개발 환경과 배포 환경을 일치시켜 "내 컴퓨터에서는 됐는데..."와 같은 문제를 원천적으로 차단합니다.
    -   `docker-compose`를 사용하면 프론트엔드, 백엔드, 데이터베이스 볼륨을 한 번의 명령으로 관리할 수 있어 테스트와 배포가 매우 편리합니다.

## 구현한 요구사항 체크리스트

-   [x] **최소 요구사항**
    -   [x] 좌석 현황 표시 (3x3 격자)
    -   [x] 좌석 예약 기능 (성공/실패 피드백 포함)
    -   [x] API 엔드포인트 (좌석 목록 조회, 좌석 예약)
    -   [x] 코드 품질 보장 (단위/통합 테스트, 타입 체크, 린팅)
-   [x] **기본 요구사항**
    -   [x] 사용자 경험 개선 (직관적 UI, 알림 시스템, 접근성, 반응형)
    -   [x] 안정적인 서비스 운영 (예외 처리, 데이터 정합성)
-   [x] **심화 요구사항**
    -   [x] 동시성 제어 (JPA Optimistic Locking + 선점 검증)
    -   [x] 실시간 좌석 상태 동기화 (Smart Polling + Hash 기반 변경 감지)
    -   [x] 선택한 좌석에 대한 우선순위 제공 (5분 TTL + 시각적 구분)

## 각 요구사항별 해결 방법 설명

### 최소 요구사항

1.  **좌석 현황 표시**:
    -   React `useState`와 `useEffect`를 사용하여 백엔드 API(`GET /api/seats`)에서 좌석 목록을 비동기적으로 받아옵니다.
    -   받아온 좌석 데이터를 3x3 `grid` CSS 레이아웃을 가진 `SeatGrid` 컴포넌트에 렌더링합니다.
    -   각 좌석의 `isReserved` 상태에 따라 조건부 CSS 클래스(`available`, `reserved`)를 적용하여 시각적으로 구분했습니다.

2.  **좌석 예약 기능**:
    -   사용자가 예약 가능한 좌석을 클릭하면, 선택된 좌석 정보를 `App` 컴포넌트의 상태로 저장하고 `ReservationForm` 컴포넌트를 렌더링합니다.
    -   예약자 이름 입력 후 '예약 확정' 버튼을 누르면 `POST /api/seats/{id}/reserve` API를 호출합니다.
    -   백엔드 `SeatService`에서는 `Math.random() < 0.01` 조건을 통해 1% 확률로 의도적인 예약 실패를 시뮬레이션하고, `ReservationFailedException`을 발생시킵니다.
    -   API 호출 결과에 따라 `alert()`을 통해 성공 메시지를, 예약 실패 시에는 Form 내에 에러 메시지를 명확하게 표시하여 사용자에게 피드백을 제공합니다.

3.  **API 엔드포인트**:
    -   `SeatController`에 두 개의 엔드포인트를 구현했습니다.
        -   `GET /api/seats`: 모든 좌석의 현재 상태를 JSON 배열로 반환합니다.
        -   `POST /api/seats/{id}/reserve`: 예약자 정보를 받아 좌석을 예약 처리하고, 업데이트된 좌석 정보를 반환합니다.

4.  **코드 품질 보장**:
    -   **테스트**: 
        - **단위 테스트**: JUnit5와 Mockito를 사용한 `SeatService` 비즈니스 로직 테스트
        - **통합 테스트**: `@SpringBootTest`와 `TestRestTemplate`을 활용한 전체 스택 API 테스트
        - **동시성 테스트**: `ExecutorService`를 사용한 멀티스레드 환경에서의 좌석 예약 동시성 검증
        - **심화 요구사항 테스트**: 모든 심화 요구사항을 검증하는 포괄적인 JUnit 통합 테스트 구현 (기존 쉘 스크립트 대체)
        - **모든 테스트 통과**: 25개의 테스트 케이스가 안정적으로 통과
    -   **타입 체크**: 프론트엔드 프로젝트 전체에 TypeScript Strict 모드를 적용하여 타입 안전성을 최대화했습니다.
    -   **린팅**: ESLint 설정을 통해 일관된 코드 스타일을 유지하고, `any` 타입 사용을 금지하여 타입 안전성을 강화했습니다.

### 기본 요구사항

1.  **사용자 경험 개선**:
    -   **직관적인 UI**: 좌석 선택 -> 정보 입력 -> 예약 확정으로 이어지는 단순하고 명확한 워크플로우를 채택했습니다.
    -   **알림 시스템**: `alert()` 대신 우아한 Toast 알림 컴포넌트를 구현하여 성공/실패 메시지를 시각적으로 구분하고 자동 사라짐 기능을 제공합니다.
    -   **접근성 향상**: 좌석에 ARIA 라벨 추가, `<button>` 요소 사용으로 키보드 탐색 지원, Focus 상태 시각화를 통해 스크린 리더와 키보드 사용자를 지원합니다.
    -   **로딩 상태**: 스피너 애니메이션과 명확한 상태 메시지를 통해 네트워크 지연 상황에서 사용자 경험을 개선했습니다.
    -   **모바일 최적화**: 44px 이상의 터치 타겟, 반응형 그리드 레이아웃, 적절한 브레이크포인트(768px, 480px)를 통해 모바일 친화적인 UI를 제공합니다.

2.  **안정적인 서비스 운영**:
    -   **예외 처리**: Spring의 `@ControllerAdvice`와 `@ExceptionHandler`를 사용하여 서비스 전반의 예외를 일관되게 처리합니다. 존재하지 않는 좌석(`404 Not Found`), 이미 예약된 좌석(`409 Conflict`), 서버 내부 오류(`500 Internal Server Error`) 등 상황에 맞는 HTTP 상태 코드와 명확한 에러 메시지를 반환하여 클라이언트가 에러 상황에 대처할 수 있도록 했습니다.
    -   **데이터 정합성**: 좌석 예약 로직을 `@Transactional` 어노테이션을 사용하여 트랜잭션 내에서 처리했습니다. 이를 통해 데이터베이스 작업이 중간에 실패할 경우 모든 변경사항이 롤백되어 데이터의 일관성을 보장합니다.

### 심화 요구사항

1.  **동시성 제어**:
    -   **문제 상황**: 여러 사용자가 동시에 같은 좌석을 예약하려고 시도하는 경우
    -   **해결 방법**: 
        - **JPA Optimistic Locking**: `Seat` 엔티티에 `@Version` 필드를 추가하여 낙관적 잠금을 구현했습니다.
        - **선점 검증**: 좌석 선택 시 이미 다른 사용자가 선택했는지 검증하여 "First Come, First Served" 원칙을 적용했습니다.
        - **Exception 처리**: `OptimisticLockingFailureException` 발생 시 `ConcurrentReservationException`으로 변환하여 명확한 에러 메시지를 제공합니다.
    -   **검증 방법**: 
        - **JUnit 통합 테스트**: `SeatIntegrationTest.testConcurrencyControl()`에서 2개 스레드가 동시에 같은 좌석을 선택할 때 하나만 성공하는지 검증
        - **동시성 부하 테스트**: `SeatIntegrationTest.testConcurrentOperations()`에서 10개 스레드 × 10개 작업으로 동시성 제어가 대규모 환경에서도 작동함을 확인
    -   **한계점**: 완전한 분산 환경에서는 Redis 등의 외부 저장소를 사용한 분산 락이 더 적합할 수 있습니다.

2.  **실시간 좌석 상태 동기화**:
    -   **문제 상황**: UI에서 사용자들이 이미 선택된 좌석을 선택하게 되는 경우
    -   **해결 방법**:
        - **Smart Polling**: 브라우저 가시성 API를 활용하여 탭이 활성화된 경우에만 3초 간격으로 폴링합니다.
        - **Hash 기반 변경 감지**: 좌석 상태의 MD5 해시를 생성하여 변경사항이 있을 때만 전체 데이터를 새로 가져옵니다.
        - **효율적인 업데이트**: `lastModified` 타임스탬프를 통해 불필요한 데이터 전송을 최소화했습니다.
    -   **검증 방법**: 
        - **JUnit 통합 테스트**: `SeatIntegrationTest.testRealTimeUpdates()`에서 좌석 상태 변경 시 해시값이 변경되는지 검증
        - **실제 브라우저 테스트**: 여러 브라우저 탭에서 동시에 접속하여 한 탭에서 좌석 상태 변경 시 다른 탭에서 실시간으로 반영되는지 확인
    -   **한계점**: WebSocket이나 Server-Sent Events 대비 네트워크 효율성이 떨어질 수 있으나, 구현 복잡도가 낮아 신뢰성이 높습니다.

3.  **선택한 좌석에 대한 우선순위 제공**:
    -   **문제 상황**: 좌석 선택 후 예약자 정보를 입력하는 동안 다른 사용자가 좌석을 예약하게 되는 경우
    -   **해결 방법**:
        - **임시 선택 시스템**: `selectedBy`, `selectedAt` 필드를 추가하여 5분간 선택 상태를 유지합니다.
        - **시각적 구분**: 자신이 선택한 좌석(주황색), 타인이 선택한 좌석(빨간색, 클릭 불가)으로 명확히 구분합니다.
        - **자동 만료**: 5분 후 자동으로 선택이 해제되며, `@Scheduled`를 통한 정리 작업이 실행됩니다.
        - **카운트다운 타이머**: 예약 폼에서 남은 시간을 실시간으로 표시하여 사용자에게 긴박감을 제공합니다.
    -   **검증 방법**: 
        - **JUnit 통합 테스트**: `SeatIntegrationTest.testSelectionPriority()`에서 선택 우선순위 시스템이 정상 작동하는지 검증
        - **정리 시스템 테스트**: `SeatIntegrationTest.testCleanupSystem()`에서 선택 취소 및 만료 로직이 정상 작동하는지 검증
        - **에지 케이스 테스트**: `SeatIntegrationTest.testEdgeCases()`에서 동일 사용자 중복 선택, 무효한 취소 시도 등을 검증
    -   **한계점**: 사용자가 브라우저를 닫은 경우 즉시 해제되지 않고 5분을 기다려야 하는 점이 있으나, Heartbeat 메커니즘 등으로 개선 가능합니다.
